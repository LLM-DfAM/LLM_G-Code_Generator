import os
import glob
import re
from pathlib import Path

# --- Configuration ---
# G-code directory generated by slicing software (with header and footer provided)
SLICER_DIR = "dataset/gcode_files"

# G-code directory generated by LLM
LLM_DIR = "DeepSeek-G-Coder_generate_gcode_files"

# Output directory after merging the header and footer
OUTPUT_DIR = "DeepSeek-G-Coder_generate_gcode_files-complete"

# Start and end maker
START_MARKER = "; start printing object, unique label id: 15"
END_MARKER = "; stop printing object, unique label id: 15"


def read_file(path):
    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
        return f.read()


def write_file(path, content):
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)


def parse_params_from_filename(filename):
    """
    Parse parameters (module, teeth_count, bore_diameter) from the file name
    """
    try:
        module_match = re.search(r"module-(\d+(?:\.\d+)?)", filename)
        teeth_match = re.search(r"teeth_count-(\d+)", filename)
        bore_match = re.search(r"bore_diameter-(\d+(?:\.\d+)?)", filename)

        if module_match and teeth_match and bore_match:
            m = float(module_match.group(1))
            z = int(teeth_match.group(1))
            b = float(bore_match.group(1))

            m = round(m, 2)
            b = round(b, 2)
            return (m, z, b)
        return None
    except Exception:
        return None


def build_slicer_file_index(slicer_dir):
    """
    Traverse the slice directory and establish a mapping index from (m,z,d) to file path
    """
    index = {}
    files = glob.glob(os.path.join(slicer_dir, "*.gcode"))

    for fpath in files:
        fname = os.path.basename(fpath)
        params = parse_params_from_filename(fname)
        if params:
            index[params] = fpath

    return index


def main():
    # 1. Check if the directory exists
    if not os.path.exists(SLICER_DIR):
        return
    if not os.path.exists(LLM_DIR):
        return

    os.makedirs(OUTPUT_DIR, exist_ok=True)

    # 2. Index slice files
    slicer_index = build_slicer_file_index(SLICER_DIR)

    # 3. Obtain the list of LLM-based G-code files
    llm_files = glob.glob(os.path.join(LLM_DIR, "*.gcode"))
    total_files = len(llm_files)

    if total_files == 0:
        return

    # 4. Define statistics value
    stats = {
        "complete": 0,
        "incomplete": 0,
        "stitched": 0,
        "errors": 0,
        "incomplete_list": []
    }

    # 5. Traversal processing
    for llm_path in llm_files:
        filename = os.path.basename(llm_path)

        llm_params = parse_params_from_filename(filename)
        if not llm_params:
            stats["errors"] += 1
            continue

        slicer_path = slicer_index.get(llm_params)

        if not slicer_path:
            m, t, b = llm_params
            stats["errors"] += 1
            continue

        try:
            llm_content = read_file(llm_path)
        except Exception as e:
            stats["errors"] += 1
            continue

        # --- Check completeness ---
        clean_start_marker = "; start printing object, unique label id: 15"
        clean_end_marker = "; stop printing object, unique label id: 15"

        start_idx = llm_content.find(clean_start_marker)
        end_idx = llm_content.find(clean_end_marker)

        is_complete = (start_idx != -1) and (end_idx != -1) and (end_idx > start_idx)

        if not is_complete:
            stats["incomplete"] += 1
            stats["incomplete_list"].append(filename)
            continue

        stats["complete"] += 1

        # --- Extracting the core part of LLM-based G-code ---
        # Extracting the part between markers (excluding markers)
        core_content = llm_content[start_idx + len(clean_start_marker):end_idx]

        # --- Extract the header and footer parts of OrcaSlicer-based G-code ---
        try:
            slicer_content = read_file(slicer_path)
        except Exception as e:
            stats["errors"] += 1
            continue

        s_start_idx = slicer_content.find(clean_start_marker)
        s_end_idx = slicer_content.find(clean_end_marker)

        if s_start_idx == -1 or s_end_idx == -1:
            stats["errors"] += 1
            continue

        header_part = slicer_content[:s_start_idx + len(clean_start_marker)]
        footer_part = slicer_content[s_end_idx:]

        # --- Concatenation ---
        # Header (including Start) + Core (without Marker) + Footer (including End)
        full_gcode = header_part + core_content + footer_part

        # --- Save ---
        out_path = os.path.join(OUTPUT_DIR, out_filename)

        try:
            write_file(out_path, full_gcode)
            stats["stitched"] += 1
        except Exception as e:
            stats["errors"] += 1

    # 6. Output Statistical Report
    print("\n" + "=" * 50)
    print("G-code Integrity and Stitching Statistics Report")
    print("=" * 50)
    print(f"Total Files       : {total_files}")
    print(f"Complete Files    : {stats['complete']}")
    print(f"Incomplete Files  : {stats['incomplete']}")
    print(f"Stitched Files    : {stats['stitched']}")
    print(f"Other Errors      : {stats['errors']}")

    if total_files > 0:
        complete_rate = (stats['complete'] / total_files) * 100
        incomplete_rate = (stats['incomplete'] / total_files) * 100
        print(f"Completion Rate   : {complete_rate:.2f}%")
        print(f"Incomplete Rate   : {incomplete_rate:.2f}%")

    if stats['incomplete_list']:
        print("-" * 50)
        print(f"List of Incomplete Files (First 10):")
        for f in stats['incomplete_list'][:10]:
            print(f" - {f}")
        if len(stats['incomplete_list']) > 10:
            print(f" ... and {len(stats['incomplete_list'])} total files")

    print("=" * 50)
    print(f"Stitched files saved to: {OUTPUT_DIR}")


if __name__ == "__main__":
    main()